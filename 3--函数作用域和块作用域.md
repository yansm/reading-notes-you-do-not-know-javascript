#函数作用域和块作用域

##1&2.函数中的作用域&隐藏内部实现

**函数作用域的含义是指：属于这个函数的全部变量都可以在这个函数的范围内使用及复用（实事上嵌套的作用域也可以使用）。**

常用的关于函数作用域的应用就是规避冲突，插件暴露给全局的接口只有一个，这样做便于规避冲突。

另一种方法即模块管理。它**强制所有的标识符都不能注意到共享作用域中，而是保持在私有，无冲突的作用域中，这样可以有效的规避所有的意外冲突。**

jquery通过noConflict来释放$的控制权，boot的插件中也有类似释放函数名控制权的代码，我们在写插件的时候提倡这么做来进一步的确保全局冲突。

##3.函数作用域

**始终给杉树表达式命名是一个最佳实践**

    setTimeout(funciton timeoutHandler(){
      console.log('hehe')
    },0)

好处有便于调试，便于引用以及语义明确。

但是并不觉得这是一个很好的实践。应用匿名函数的情况本身他的语义就应该在他的载体上。

***

立即执行函数表达式

    (function(){
      //@todo
    })()

以及

    （function(){
      //@toto
    }()）

独立作用域，最常见的问题：

    for(var i = 0; i < 10; i++) {
      setTimeout(function(){
        console.log(i);//都是10
      }, 0)
    }

解决方法：

    for(var i = 0; i < 10; i++) {
      (function(i){
        setTimeout(function(){
          console.log(i);
        }, 0)
      })(i)
    }

这里解决的方法虽然是闭包，但是涉及到的是变量提升原则以及js的异步实现机制。首先是因为没有块作用域，所以var i;提升到了全局，以及setTimeout导致所有的运行都放在了异步的队列里，当for运行完毕才依次运行，这时候全局的i已经变成了10。我们用闭包就是将i持久的留存在了闭包作用域里。

我们一般会在依次绑定事件的时候遇到相同的问题，到时需要注意。

此外虽然setTimeout(function(){}, 0)在这里是困扰，但是在很多时候他都有很实际的应用的情况。他使我们能够运行一个异步，当我们的代码不想在此时运行的时候，比如在pc浏览器上，当我们监听keydown获取获取的值是按下这个键之前的值，但是如果我们把它包在setTimeout 0里就可以获取到之后的值，但是在移动浏览器里不行，具体原因能力有限，还在看相关资料。

以及当我们想添加两个class让其发生动画效果的时候 

    $div.addClass('animate');
    $div.addClass('animate-active');

但是效果不会出现，我们只需要把第二句放在setTimeout 0里即可。这也是一个常用的应用情况。

熟练的理解异步队列有助于理解setTimeout 0的应用场景。

***

另一个闭包应用即解决undefined默认值的问题。

    (function(undefined){
      @todo
    })();

需要如此做是因为在js中，undefined是一个全局的变量，在非严模式下是可以通过赋值来覆盖变量的，虽然在严格模式下这种行为会报错，但是我们依旧可以通过何通过函数声明的方式来覆盖undefined的值。原因声明中函数优先的原则，这个在后面会提到。所以，在必报的时候传递一个undefined是一个好习惯。

***

最后的闭包应用即用来写插件。他除了上述两种方式外其实也可以这么写：

    +function(){}();
    !function(){}();
    ~function(){}();

这几种方式除了上述的闭包优势外还有另外一个有点，即如果上文中有为封闭的括号可以避免被其污染。boot的插件封装即这种方式。

但需要注意的是当闭包被用来赋值的时候不要这么做。比如：

    var a = (function(){
      return {
        //api
      };
    })();
    
这种时候应用上述三种方式会造成强转，因为归根结底这些操作符做的就是强转。
 
***
 
另外一种很常见的模式是：

    (function (fn){
        fn(window);
    }(function(a){
      //@todo
    })）

这种方式很常见，如jquery判断应用什么模块化的时候。

##4.块作用域

es5中大部分情况下是没有块作用域的。除了with和try/catch。但是前者不建议应用，后者并不会因为是块作用域而引发什么错误，所以只需了解即可。

es6中是存在块作用域的。let,const都会查找块作用域。比如我们的for这么写就可以避免变量提升:

    for(let i = 0; i < length; i++) {
      //@todo
    }

但是let,const也会避免变量提升原则（多么有趣的原则···，就这么没了），

需要注意的是，这虽然是好事，但是我们需要注意两点，第一就是不可以重复声明了，这个没什么大碍，正常些代码也不会这么写，第二，这个很重要，即typeof 在不是一个百分百安全的函数了，typeof我们最常应用的场景就是判断一个变量是否声明，但如果这个变量是用let，const声明的，我们就会出现暂时性死区的问题。这个很重要。

再拓展一些。

typeof由于对null等不准确，所以我们一般只用来用他来验证是否为undefined。

另一个操作是instanceof。 他用来判断类型也是不准确的。 如

    'str' instanceof String; //false
    String('str') instanceof String;  //false
    new String('str') instanceof String;  //true
    
一般用他来判断包含关系。

我们常用的判断类型的方式是：

    Object.prototype.toString.call(XXX).slice(8,-1);

这个是最准确的

***

最后，虽然这很常识，但是还是记录下来避免混乱。

const,let与var一样都是地址赋值。即：

    const a = {b: 2};
    a.b = 3;
    
是可以的，因为a的堆地址并没有改变。 
